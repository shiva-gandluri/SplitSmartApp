User Story 1: Edit Existing Bill
  As a bill creator
  I want to edit bills I've created
  So that I can correct mistakes, add/remove participants, or reassign items after bill creation. 

  Acceptance Criteria:
  - Edit button (pencil icon) appears in toolbar of bill detail view only for bill creators
  - Edit button opens a full editing interface with all original bill data pre-populated
  - I can modify bill name, items, prices, participants, and who paid the bill
  - All changes are validated before saving (all items assigned, payer selected, totals match)
  - Updated bill replaces original bill atomically (no duplicate bills)
  - All participants receive automatic notifications of changes
  - History shows "(Updated)" indicator for modified bills\

  Priority: High \
  Please make sure that the current UI/UX patterns are not modified. For example, buttons on "Assign Items" page 
  etc. Please ask if you have any questions. Don't implement unless you are atleast 98% sure on what needs to be 
  done. Please identify potential edge cases or risks as if you're top 1% engineers.

---


⏺ Perfect! Thank you for the clear guidance. Now I have 98%+ confidence on the requirements. Let me design the
  implementation:

  Implementation Design

  1. Version Tracking (Simple & Standard)

  Add to Bill model:
  let version: Int = 1  // Increment on each edit
  let isUpdated: Bool = false  // For "(Updated)" indicator

  2. Edit Flow Design - Reuse BillSplitSession

  - BillDetailView gets Edit button in toolbar (pencil icon)
  - EditBillCoordinator populates BillSplitSession from existing Bill
  - Reuse existing screens: Scan → Assign → Summary with "Update Bill" instead of "Add Bill"
  - BillService gets updateBill() method alongside createBill()

  3. Authorization Pattern

  // In BillDetailView
  var canEdit: Bool {
      guard let currentUser = Auth.auth().currentUser else { return false }
      return currentUser.uid == bill.createdBy
  }

  4. UI Flow Pattern

  BillDetailView (with Edit toolbar) →
  EditBillFlow (reuses existing screens) →
  Updated BillDetailView (shows "Updated" indicator)

  5. Implementation Structure:

  1. Extend Bill model - Add version and isUpdated fields
  2. Add Edit button to BillDetailView toolbar - Only for bill creators
  3. Create BillEditCoordinator - Populates session from existing bill
  4. Extend BillService - Add updateBill() method with version increment
  5. Update notifications - Send "Bill updated" vs "New bill" messages
  6. Add validation - Same constraints as creation (totals must match)

  Key Technical Decisions:
  - ✅ Simple versioning: Just increment integer, set isUpdated flag
  - ✅ Reuse existing UI: Same screens, different flow coordinator
  - ✅ Authorization: Check currentUser.uid == bill.createdBy
  - ✅ Validation: Same rules as bill creation (totals must match)
  - ✅ Error handling: Standard "Couldn't complete. Please retry" pattern