rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Rate limiting function - basic time-based throttling
    function checkRateLimit(operation) {
      // Allow normal operations but track timing to prevent abuse
      // In production, you'd implement more sophisticated rate limiting
      // For now, we rely on Firebase's built-in rate limiting + client-side throttling
      return request.time > timestamp.date(2023, 1, 1);
    }
    
    // Users can only access their own user document - NO cross-user access
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Secure: Each user can only access their own data
      
      // User contacts subcollection - users can only access their own contacts
      match /contacts/{contactId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && 
          request.auth.uid == userId &&
          // Validate contact data structure and constraints
          validateContactData(request.resource.data);
      }
      
      // User transaction contacts subcollection - users can only access their own transaction contacts
      match /transactionContacts/{contactId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && 
          request.auth.uid == userId &&
          // Validate transaction contact data structure and constraints
          validateTransactionContactData(request.resource.data);
      }
    }
    
    // New secure participant lookup collection - contains only minimal public data
    match /participants/{participantId} {
      allow read: if request.auth != null && checkRateLimit('read');
      allow write: if request.auth != null && request.auth.uid == participantId && checkRateLimit('write');
      allow create: if request.auth != null && request.auth.uid == request.resource.id && checkRateLimit('create');
    }
    
    // Bill split sessions - users can only access sessions they participate in
    match /sessions/{sessionId} {
      allow read, write: if request.auth != null && 
        request.auth.uid in resource.data.participantIds;
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.createdBy &&
        // Validate session data structure and constraints
        validateSessionData(request.resource.data);
    }
    
    // Session data validation function
    function validateSessionData(data) {
      return data.keys().hasAll(['createdBy', 'participantIds', 'createdAt']) &&
             data.createdBy is string &&
             data.participantIds is list &&
             data.participantIds.size() >= 1 &&
             data.participantIds.size() <= 50 && // Max 50 participants
             data.createdBy in data.participantIds &&
             // Validate optional fields
             (!('total' in data) || (data.total is number && data.total >= 0)) &&
             (!('status' in data) || data.status in ['active', 'completed', 'cancelled']) &&
             (!('items' in data) || data.items is list);
    }
    
    // Expenses - users can only access expenses they're involved in
    match /expenses/{expenseId} {
      allow read, write: if request.auth != null && (
        request.auth.uid == resource.data.paidBy ||
        request.auth.uid in resource.data.participants
      );
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.paidBy &&
        // Validate expense data structure and constraints
        validateExpenseData(request.resource.data);
    }
    
    // Expense data validation function
    function validateExpenseData(data) {
      return data.keys().hasAll(['paidBy', 'participants', 'amount', 'description', 'createdAt']) &&
             data.paidBy is string &&
             data.participants is list &&
             data.participants.size() >= 1 &&
             data.participants.size() <= 50 && // Max 50 participants
             data.paidBy in data.participants &&
             data.amount is number &&
             data.amount > 0 &&
             data.amount <= 1000000 && // Max $1M per expense
             data.description is string &&
             data.description.size() >= 1 &&
             data.description.size() <= 500 && // Max 500 characters
             // Validate optional fields
             (!('category' in data) || (data.category is string && data.category.size() <= 100));
    }
    
    // Groups for recurring split arrangements
    match /groups/{groupId} {
      allow read, write: if request.auth != null && 
        request.auth.uid in resource.data.members;
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.createdBy &&
        // Validate group data structure and constraints
        validateGroupData(request.resource.data);
    }
    
    // Group data validation function
    function validateGroupData(data) {
      return data.keys().hasAll(['createdBy', 'members', 'name', 'createdAt']) &&
             data.createdBy is string &&
             data.members is list &&
             data.members.size() >= 2 &&
             data.members.size() <= 100 && // Max 100 members per group
             data.createdBy in data.members &&
             data.name is string &&
             data.name.size() >= 1 &&
             data.name.size() <= 100 && // Max 100 characters for group name
             // Validate optional fields
             (!('description' in data) || (data.description is string && data.description.size() <= 500));
    }
    
    // Contact data validation function
    function validateContactData(data) {
      return data.keys().hasAll(['id', 'fullName', 'email', 'createdAt', 'updatedAt']) &&
             data.id is string &&
             data.id.size() >= 1 &&
             data.id.size() <= 100 &&
             data.fullName is string &&
             data.fullName.size() >= 2 &&
             data.fullName.size() <= 100 && // Max 100 characters for full name
             data.email is string &&
             data.email.size() >= 5 && // Minimum valid email like "a@b.c"
             data.email.size() <= 254 && // RFC 5321 limit for email addresses
             data.email.matches('.*@.*\\..*') && // Basic email format validation
             data.createdAt is timestamp &&
             data.updatedAt is timestamp &&
             // Validate optional fields
             (!('phoneNumber' in data) || (data.phoneNumber is string && data.phoneNumber.size() <= 50));
    }
    
    // Transaction contact data validation function
    function validateTransactionContactData(data) {
      return data.keys().hasAll(['id', 'displayName', 'email', 'lastTransactionAt', 'totalTransactions', 'createdAt', 'updatedAt']) &&
             data.id is string &&
             data.id.size() >= 1 &&
             data.id.size() <= 100 &&
             data.displayName is string &&
             data.displayName.size() >= 2 &&
             data.displayName.size() <= 100 && // Max 100 characters for display name
             data.email is string &&
             data.email.size() >= 5 && // Minimum valid email like "a@b.c"
             data.email.size() <= 254 && // RFC 5321 limit for email addresses
             data.email.matches('.*@.*\\..*') && // Basic email format validation
             data.lastTransactionAt is timestamp &&
             data.totalTransactions is number &&
             data.totalTransactions >= 1 &&
             data.totalTransactions <= 10000 && // Reasonable limit
             data.createdAt is timestamp &&
             data.updatedAt is timestamp &&
             // Validate optional fields
             (!('phoneNumber' in data) || (data.phoneNumber is string && data.phoneNumber.size() <= 50)) &&
             (!('contactUserId' in data) || (data.contactUserId is string && data.contactUserId.size() <= 100)) &&
             (!('nickname' in data) || (data.nickname is string && data.nickname.size() <= 50));
    }
    
    // System collections - read-only for maintenance
    match /_system/{document=**} {
      allow read: if request.auth != null;
      allow write: if false; // Only via admin SDK
    }
    
    // Default deny all other collections for security
    match /{document=**} {
      allow read, write: if false;
    }
  }
}